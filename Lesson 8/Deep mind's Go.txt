484 | NATURE | VOL 529 | 28 JANUARY 2016
ARTICLE
doi:10.1038/nature16961
Mastering the game of Go with deep
neural networks and tree search
David Silver1
*, Aja Huang1
*, Chris J. Maddison1
, Arthur Guez1
, Laurent Sifre1
, George van den Driessche1
,
Julian Schrittwieser1
, Ioannis Antonoglou1
, Veda Panneershelvam1
, Marc Lanctot1
, Sander Dieleman1
, Dominik Grewe1
,
John Nham2
, Nal Kalchbrenner1
, Ilya Sutskever2
, Timothy Lillicrap1
, Madeleine Leach1
, Koray Kavukcuoglu1
,
Thore Graepel1
 & Demis Hassabis1
All games of perfect information have an optimal value function, v*
(s),
which determines the outcome of the game, from every board position
or state s, under perfect play by all players. These games may be solved
by recursively computing the optimal value function in a search tree
containing approximately bd
 possible sequences of moves, where b is
the game’s breadth (number of legal moves per position) and d is its
depth (game length). In large games, such as chess (b?35, d?80)1
 and
especially Go (b?250, d?150)1
, exhaustive search is infeasible2,3
, but
the effective search space can be reduced by two general principles.
First, the depth of the search may be reduced by position evaluation:
truncating the search tree at state s and replacing the subtree below s
by an approximate value function v(s)?v*
(s) that predicts the outcome
from state s. This approach has led to superhuman performance in
chess4
, checkers5
 and othello6
, but it was believed to be intractable in Go
due to the complexity of the game7
. Second, the breadth of the search
may be reduced by sampling actions from a policy p(a|s) that is a probability distribution over possible moves a in position s. For example,
Monte Carlo rollouts8
 search to maximum depth without branching
at all, by sampling long sequences of actions for both players from a
policy p. Averaging over such rollouts can provide an effective position
evaluation, achieving superhuman performance in backgammon8
 and
Scrabble9
, and weak amateur level play in Go10.
Monte Carlo tree search (MCTS)11,12 uses Monte Carlo rollouts
to estimate the value of each state in a search tree. As more simulations are executed, the search tree grows larger and the relevant
values become more accurate. The policy used to select actions during
search is also improved over time, by selecting children with higher
values. Asymptotically, this policy converges to optimal play, and the
evaluations converge to the optimal value function12. The strongest
current Go programs are based on MCTS, enhanced by policies that
are trained to predict human expert moves13. These policies are used
to narrow the search to a beam of high-probability actions, and to
sample actions during rollouts. This approach has achieved strong
amateur play13–15. However, prior work has been limited to shallow
policies13–15 or value functions16 based on a linear combination of
input features.
Recently, deep convolutional neural networks have achieved unprecedented performance in visual domains: for example, image classification17, face recognition18, and playing Atari games19. They use many
layers of neurons, each arranged in overlapping tiles, to construct
increasingly abstract, localized representations of an image20. We
employ a similar architecture for the game of Go. We pass in the board
position as a 19?19 image and use convolutional layers to construct a
representation of the position. We use these neural networks to reduce
the effective depth and breadth of the search tree: evaluating positions
using a value network, and sampling actions using a policy network.
We train the neural networks using a pipeline consisting of several
stages of machine learning (Fig. 1). We begin by training a supervised
learning (SL) policy network p? directly from expert human moves.
This provides fast, efficient learning updates with immediate feedback
and high-quality gradients. Similar to prior work13,15, we also train a
fast policy p? that can rapidly sample actions during rollouts. Next, we
train a reinforcement learning (RL) policy network p? that improves
the SL policy network by optimizing the final outcome of games of selfplay. This adjusts the policy towards the correct goal of winning games,
rather than maximizing predictive accuracy. Finally, we train a value
network v? that predicts the winner of games played by the RL policy
network against itself. Our program AlphaGo efficiently combines the
policy and value networks with MCTS.
Supervised learning of policy networks
For the first stage of the training pipeline, we build on prior work
on predicting expert moves in the game of Go using supervised
learning13,21–24. The SL policy network p?(a|?s) alternates between convolutional layers with weights ?, and rectifier nonlinearities. A final softmax layer outputs a probability distribution over all legal moves a. The
input s to the policy network is a simple representation of the board state
(see Extended Data Table 2). The policy network is trained on randomly
The game of Go has long been viewed as the most challenging of classic games for artificial intelligence owing to its
enormous search space and the difficulty of evaluating board positions and moves. Here we introduce a new approach
to computer Go that uses ‘value networks’ to evaluate board positions and ‘policy networks’ to select moves. These deep
neural networks are trained by a novel combination of supervised learning from human expert games, and reinforcement
learning from games of self-play. Without any lookahead search, the neural networks play Go at the level of stateof-the-art Monte Carlo tree search programs that simulate thousands of random games of self-play. We also introduce a
new search algorithm that combines Monte Carlo simulation with value and policy networks. Using this search algorithm,
our program AlphaGo achieved a 99.8% winning rate against other Go programs, and defeated the human European Go
champion by 5 games to 0. This is the first time that a computer program has defeated a human professional player in the
full-sized game of Go, a feat previously thought to be at least a decade away.
1Google DeepMind, 5 New Street Square, London EC4A 3TW, UK. 2Google, 1600 Amphitheatre Parkway, Mountain View, California 94043, USA.
*These authors contributed equally to this work.
© 2016 Macmillan Publishers Limited. All rights reserved
28 JANUARY 2016 | VOL 529 | NATURE | 485
ARTICLE RESEARCH
sampled state-action pairs (s, a), using stochastic gradient ascent to
maximize the likelihood of the human move a selected in state s
?? ? ? ? ( | )
?
? log p a s
We trained a 13-layer policy network, which we call the SL policy
network, from 30 million positions from the KGS Go Server. The network predicted expert moves on a held out test set with an accuracy of
57.0% using all input features, and 55.7% using only raw board position and move history as inputs, compared to the state-of-the-art from
other research groups of 44.4% at date of submission24 (full results in
Extended Data Table 3). Small improvements in accuracy led to large
improvements in playing strength (Fig. 2a); larger networks achieve
better accuracy but are slower to evaluate during search. We also
trained a faster but less accurate rollout policy p?(a|s), using a linear
softmax of small pattern features (see Extended Data Table 4) with
weights ?; this achieved an accuracy of 24.2%, using just 2?s to select
an action, rather than 3ms for the policy network.
Reinforcement learning of policy networks
The second stage of the training pipeline aims at improving the policy
network by policy gradient reinforcement learning (RL)25,26. The RL
policy network p? is identical in structure to the SL policy network,
and its weights ? are initialized to the same values, ?=?. We play
games between the current policy network p? and a randomly selected
previous iteration of the policy network. Randomizing from a pool
of opponents in this way stabilizes training by preventing overfitting
to the current policy. We use a reward function r(s) that is zero for all
non-terminal time steps t<T. The outcome zt=±r(sT) is the terminal reward at the end of the game from the perspective of the current
player at time step t: +1 for winning and ?1 for losing. Weights are
then updated at each time step t by stochastic gradient ascent in the
direction that maximizes expected outcome25
??
? ? ? ( | )
?
?p a s z log t t
t
We evaluated the performance of the RL policy network in game
play, sampling each move ~ (?| ) ? at t p s from its output probability
distribution over actions. When played head-to-head, the RL policy
network won more than 80% of games against the SL policy network.
We also tested against the strongest open-source Go program, Pachi14,
a sophisticated Monte Carlo search program, ranked at 2 amateur dan
on KGS, that executes 100,000 simulations per move. Using no search
at all, the RL policy network won 85% of games against Pachi. In comparison, the previous state-of-the-art, based only on supervised
Figure 1 | Neural network training pipeline and architecture. a, A fast
rollout policy p? and supervised learning (SL) policy network p? are
trained to predict human expert moves in a data set of positions.
A reinforcement learning (RL) policy network p? is initialized to the SL
policy network, and is then improved by policy gradient learning to
maximize the outcome (that is, winning more games) against previous
versions of the policy network. A new data set is generated by playing
games of self-play with the RL policy network. Finally, a value network v?
is trained by regression to predict the expected outcome (that is, whether
the current player wins) in positions from the self-play data set.
b, Schematic representation of the neural network architecture used in
AlphaGo. The policy network takes a representation of the board position
s as its input, passes it through many convolutional layers with parameters
? (SL policy network) or ? (RL policy network), and outputs a probability
distribution ( | ) ?p a s or ( | ) ?
p a s over legal moves a, represented by a
probability map over the board. The value network similarly uses many
convolutional layers with parameters ?, but outputs a scalar value v?(s?)
that predicts the expected outcome in position s?.
Regression
Classication
Classication
Self Play
Policy gradient
a b
Human expert positions Self-play positions
Neural network Data
Rollout policy
pS pV pVU (a?s) QT p (s?) U QT
SL policy network RL policy network Value network Policy network Value network
s s?
Figure 2 | Strength and accuracy of policy and value networks.
a, Plot showing the playing strength of policy networks as a function
of their training accuracy. Policy networks with 128, 192, 256 and 384
convolutional filters per layer were evaluated periodically during training;
the plot shows the winning rate of AlphaGo using that policy network
against the match version of AlphaGo. b, Comparison of evaluation
accuracy between the value network and rollouts with different policies.
Positions and outcomes were sampled from human expert games. Each
position was evaluated by a single forward pass of the value network v?,
or by the mean outcome of 100 rollouts, played out using either uniform
random rollouts, the fast rollout policy p?, the SL policy network p? or
the RL policy network p?. The mean squared error between the predicted
value and the actual game outcome is plotted against the stage of the game
(how many moves had been played in the given position).
15 45 75 105 135 165 195 225 255 >285
Move number
0.10
0.15
0.20
0.25
0.30
0.35
0.40
0.45
0.50
Mean squared error
on expert games
Uniform random
rollout policy
Fast rollout policy
Value network
SL policy network
RL policy network
50 51 52 53 54 55 56 57 58 59
Training accuracy on KGS dataset (%)
0
10
20
30
40
50
60
70
128 lters
192 lters
256 lters
384 lters
AlphaGo win rate (%)
a b
© 2016 Macmillan Publishers Limited. All rights reserved
486 | NATURE | VOL 529 | 28 JANUARY 2016
RESEARCH ARTICLE
learning of convolutional networks, won 11% of games against Pachi23
and 12% against a slightly weaker program, Fuego24.
Reinforcement learning of value networks
The final stage of the training pipeline focuses on position evaluation,
estimating a value function vp
(s) that predicts the outcome from position s of games played by using policy p for both players28–30
v s( )= | E[ , z s = ~ s a … p] p t t t T
Ideally, we would like to know the optimal value function under
perfect play v*
(s); in practice, we instead estimate the value function
v ?
p for our strongest policy, using the RL policy network p?. We approximate the value function using a value network v?(s) with weights ?, ? v s ?( )? ( v s ? ) ? v s( ) p . This neural network has a similar architecture
to the policy network, but outputs a single prediction instead of a probability distribution. We train the weights of the value network by regression on state-outcome pairs (s, z), using stochastic gradient descent to
minimize the mean squared error (MSE) between the predicted value
v?(s), and the corresponding outcome z
??
? ? ? ( )
? ( ? ( )) ?
?
v s z v s
The naive approach of predicting game outcomes from data consisting of complete games leads to overfitting. The problem is that
successive positions are strongly correlated, differing by just one stone,
but the regression target is shared for the entire game. When trained
on the KGS data set in this way, the value network memorized the
game outcomes rather than generalizing to new positions, achieving a
minimum MSE of 0.37 on the test set, compared to 0.19 on the training
set. To mitigate this problem, we generated a new self-play data set
consisting of 30 million distinct positions, each sampled from a separate game. Each game was played between the RL policy network and
itself until the game terminated. Training on this data set led to MSEs
of 0.226 and 0.234 on the training and test set respectively, indicating
minimal overfitting. Figure 2b shows the position evaluation accuracy
of the value network, compared to Monte Carlo rollouts using the fast
rollout policy p?; the value function was consistently more accurate.
A single evaluation of v?(s) also approached the accuracy of Monte
Carlo rollouts using the RL policy network p?, but using 15,000 times
less computation.
Searching with policy and value networks
AlphaGo combines the policy and value networks in an MCTS algorithm (Fig. 3) that selects actions by lookahead search. Each edge
(s, a) of the search tree stores an action value Q(s, a), visit count N(s, a),
and prior probability P(s, a). The tree is traversed by simulation (that
is, descending the tree in complete games without backup), starting
from the root state. At each time step t of each simulation, an action at
is selected from state st
a Q t = ( argmax ( ) s a, , + ( u s a)) a
t t
so as to maximize action value plus a bonus
( )? ( )
+ ( ) u s a P s a
N s a , ,
1 ,
that is proportional to the prior probability but decays with
repeated visits to encourage exploration. When the traversal reaches a
leaf node sL at step L, the leaf node may be expanded. The leaf position
sL is processed just once by the SL policy network p?. The output probabilities are stored as prior probabilities P for each legal action a,
( )= ( | ) ? P s a, p a s . The leaf node is evaluated in two very different ways:
first, by the value network v?(sL); and second, by the outcome zL of a
random rollout played out until terminal step T using the fast rollout
policy p?; these evaluations are combined, using a mixing parameter
?, into a leaf evaluation V(sL)
V s( )L L = (1? ) ? ? v s ?( )+ zL
At the end of simulation, the action values and visit counts of all
traversed edges are updated. Each edge accumulates the visit count and
mean evaluation of all simulations passing through that edge
?
?
( )= ( )
( )= ( ) ( ) ( )
=
=
N s a s a i
Q s a N s a s a i V s
, 1 , ,
, 1
, 1 , ,
i
n
i
n
L
i
1
1
where sL
i
 is the leaf node from the ith simulation, and 1(s, a, i) indicates
whether an edge (s, a) was traversed during the ith simulation. Once
the search is complete, the algorithm chooses the most visited move
from the root position.
It is worth noting that the SL policy network p? performed better in
AlphaGo than the stronger RL policy network p?, presumably because
humans select a diverse beam of promising moves, whereas RL optimizes for the single best move. However, the value function
v s ?( )? ( v s ? ) p derived from the stronger RL policy network performed
Figure 3 | Monte Carlo tree search in AlphaGo. a, Each simulation
traverses the tree by selecting the edge with maximum action value Q,
plus a bonus u(P) that depends on a stored prior probability P for that
edge. b, The leaf node may be expanded; the new node is processed once
by the policy network p? and the output probabilities are stored as prior
probabilities P for each action. c, At the end of a simulation, the leaf node
is evaluated in two ways: using the value network v?; and by running
a rollout to the end of the game with the fast rollout policy p?, then
computing the winner with function r. d, Action values Q are updated to
track the mean value of all evaluations r(·) and v?(·) in the subtree below
that action.
a b Selection Expansion c d Evaluation Backup
pS
pV
Q + u(P)
Q + u Q + u(P) (P)
Q + u(P)
P P
P P
Q
Q
Q
Q
r r r r
P
max
max
P
QT
QT
QT
QT
QT QT
© 2016 Macmillan Publishers Limited. All rights reserved
28 JANUARY 2016 | VOL 529 | NATURE | 487
ARTICLE RESEARCH
better in AlphaGo than a value function v s ?( )? ( v s ? ) p derived from the
SL policy network.
Evaluating policy and value networks requires several orders of
magnitude more computation than traditional search heuristics. To
efficiently combine MCTS with deep neural networks, AlphaGo uses
an asynchronous multi-threaded search that executes simulations on
CPUs, and computes policy and value networks in parallel on GPUs.
The final version of AlphaGo used 40 search threads, 48 CPUs, and
8 GPUs. We also implemented a distributed version of AlphaGo that
exploited multiple machines, 40 search threads, 1,202 CPUs and
176 GPUs. The Methods section provides full details of asynchronous
and distributed MCTS.
Evaluating the playing strength of AlphaGo
To evaluate AlphaGo, we ran an internal tournament among variants
of AlphaGo and several other Go programs, including the strongest
commercial programs Crazy Stone13 and Zen, and the strongest open
source programs Pachi14 and Fuego15. All of these programs are based
Figure 4 | Tournament evaluation of AlphaGo. a, Results of a
tournament between different Go programs (see Extended Data Tables
6–11). Each program used approximately 5 s computation time per move.
To provide a greater challenge to AlphaGo, some programs (pale upper
bars) were given four handicap stones (that is, free moves at the start of
every game) against all opponents. Programs were evaluated on an
Elo scale37: a 230 point gap corresponds to a 79% probability of winning,
which roughly corresponds to one amateur dan rank advantage on
KGS38; an approximate correspondence to human ranks is also shown,
horizontal lines show KGS ranks achieved online by that program. Games
against the human European champion Fan Hui were also included;
these games used longer time controls. 95% confidence intervals are
shown. b, Performance of AlphaGo, on a single machine, for different
combinations of components. The version solely using the policy network
does not perform any search. c, Scalability study of MCTS in AlphaGo
with search threads and GPUs, using asynchronous search (light blue) or
distributed search (dark blue), for 2 s per move.
3,500
3,000
2,500
2,000
1,500
1,000
500
0
c
1 2 4 8 16 32
1 2 4 8
12
64
24
112
40
176
64
280
40
Single machine Distributed
a
Rollouts
Value network
Policy network
3,500
3,000
2,500
2,000
1,500
1,000
500
0
b
40
8
Threads
GPUs
3,500
3,000
2,500
2,000
1,500
1,000
500
0
Elo Rating
Crazy Ston
=HQ
Pachi
Fuego
GnuGo
e
distributed
AlphaGo
AlphaGo
Fan Hui
Pr
 dan (p)
ofessional Amateur
dan (d)
Beginner
kyu (k)
9p
7p
5p
3p
1p
9d
7d
5d
3d
1d
1k
3k
5k
7k
Figure 5 | How AlphaGo (black, to play) selected its move in an
informal game against Fan Hui. For each of the following statistics,
the location of the maximum value is indicated by an orange circle.
a, Evaluation of all successors s? of the root position s, using the value
network v?(s?); estimated winning percentages are shown for the top
evaluations. b, Action values Q(s, a) for each edge (s, a) in the tree from
root position s; averaged over value network evaluations only (?=0).
c, Action values Q(s, a), averaged over rollout evaluations only (?=1).
d, Move probabilities directly from the SL policy network, ( | ) ?
p a s ;
reported as a percentage (if above 0.1%). e, Percentage frequency with
which actions were selected from the root during simulations. f, The
principal variation (path with maximum visit count) from AlphaGo’s
search tree. The moves are presented in a numbered sequence. AlphaGo
selected the move indicated by the red circle; Fan Hui responded with the
move indicated by the white square; in his post-game commentary he
preferred the move (labelled 1) predicted by AlphaGo.
Principal variation
a Value network
Policy network Percentage of simulations f
b c Tree evaluation from value net Tree evaluation from rollouts
d e g
© 2016 Macmillan Publishers Limited. All rights reserved
488 | NATURE | VOL 529 | 28 JANUARY 2016
RESEARCH ARTICLE
on high-performance MCTS algorithms. In addition, we included the
open source program GnuGo, a Go program using state-of-the-art
search methods that preceded MCTS. All programs were allowed 5 s
of computation time per move.
The results of the tournament (see Fig. 4a) suggest that singlemachine AlphaGo is many dan ranks stronger than any previous
Go program, winning 494 out of 495 games (99.8%) against other
Go programs. To provide a greater challenge to AlphaGo, we also
played games with four handicap stones (that is, free moves for the
opponent); AlphaGo won 77%, 86%, and 99% of handicap games
against Crazy Stone, Zen and Pachi, respectively. The distributed version of AlphaGo was significantly stronger, winning 77% of games
against single-machine AlphaGo and 100% of its games against other
programs.
We also assessed variants of AlphaGo that evaluated positions
using just the value network (? = 0) or just rollouts (? = 1) (see
Fig. 4b). Even without rollouts AlphaGo exceeded the performance
of all other Go programs, demonstrating that value networks provide
a viable alternative to Monte Carlo evaluation in Go. However, the
mixed evaluation (?=0.5) performed best, winning ?95% of games
against other variants. This suggests that the two position-evaluation
mechanisms are complementary: the value network approximates the
outcome of games played by the strong but impractically slow p?, while
the rollouts can precisely score and evaluate the outcome of games
played by the weaker but faster rollout policy p?. Figure 5 visualizes
the evaluation of a real game position by AlphaGo.
Finally, we evaluated the distributed version of AlphaGo against Fan
Hui, a professional 2 dan, and the winner of the 2013, 2014 and 2015
European Go championships. Over 5–9 October 2015 AlphaGo and
Fan Hui competed in a formal five-game match. AlphaGo won the
match 5 games to 0 (Fig. 6 and Extended Data Table 1). This is the
first time that a computer Go program has defeated a human professional player, without handicap, in the full game of Go—a feat that was
previously believed to be at least a decade away3,7,31.
Discussion
In this work we have developed a Go program, based on a combination of deep neural networks and tree search, that plays at the level of
the strongest human players, thereby achieving one of artificial intelligence’s “grand challenges”31–33. We have developed, for the first time,
effective move selection and position evaluation functions for Go,
based on deep neural networks that are trained by a novel combination
Figure 6 | Games from the match between AlphaGo and the European
champion, Fan Hui. Moves are shown in a numbered sequence
corresponding to the order in which they were played. Repeated moves
on the same intersection are shown in pairs below the board. The first
move number in each pair indicates when the repeat move was played, at
an intersection identified by the second move number (see Supplementary
Information).
1 2
3
4
5
6
7
8
10 9
11
12
13
14
15 16
17
18
20 19
21
22
23
24
25
26
27
28
29 30
31
32
33
35 34
36 37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52 53
54
55
56
57
58
59
60
61
62
63
65 64
66
67
68
69
70
71 72
73
74
75
77 76
78
79
80
82 81 83
84
85
86
87
88 89
90
91
93 92
94
95
96
97
99 98
100
101 102
103 104
105
106
108 107
109
110
111
112
113
114
115 116
117
118
119
120
121
123 122
124
125
126
127
128
130 131 129
132
133
134
135
136
137
138
139
140
141
142
143
144
145 146
147
148
149 150
151
152
153
154
155
156
157
158
159
160 161
163 162
164
165
166
167
168
169
170
171 172
173
174
175
176 177
178
179
180
181 182
183
184
185
186
187
188
189
190
191
192
194 193
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213 214
215
216
217 218
219
221 220
222
223
224
226 225
227
228
229
230
231
232
233
236 235
237
238
239
240
241
242
244 243 246 247
248
249
251
252
253
254
255
256
257
258
259
260
261
262 263
264
265
267 266
268
269 270
271
272
234 at 179 245 at 122 250 at 59
1 2
3
4
5 6
7 8
9
11 10
12
13
14
15
16
17
18
20 19
21
22
23
24
25
26
28 27
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47 48
52 49 50 51
53
54 55
57 56
58
59
60
61
62 63
64
65
66
67
68
69
70
71
73 72
75 74
76 77
78
79
80
81
82
83
84
85
86
87
88
90 89
91
92
93 94
95
96
98 97 99
100
101
102
103
104
105
106
107 108
109
110
111
112
113 114
115
116
117
118
119
121 120
123 122
124
125
126
127
128
129
130
131
132
133
136 134 135
137
138
139 140
143 142 141
144
145
146
147 148
149
150 151
152
153
155 154
156
157
158
159 160
161
162
163
165 164
166
167
170 169 168 171
172
173
174
175
176
177
179 180 178
181
183
182 at 169
1 2
3 4
5
6
7
8
9 10
11
12
13
14
15
16
17
18
19 20
21
22
23
24
25
26
27
29 28
30
31
32
33
34
35
36
37 38
39
40
41 42
43 44
45
46
47
49 48
50
51
53 52
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69 70
71
72
73
74 75
76
77
78
79
80
84 83 81 82
85
86
87
88
90 89
91
92
93
94
95
96 97
98
99
100
101
102
104 103
105
106
107
108
109
111 110
112
113
114
115
116
117 118
119
120
121 122
123
124 125
126
127
128
130 129
131 132
133 134
135
136
137
138
139
140
141
142
143
145 144
146
147 148
149
150
151
152
153
154
156 155
158 157
160 159
161
163 162
164
165
166
1 2
3
4
5 6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22 23
24 25
26
28 27 29
30
32 31
33
34
35
36 37
38
39
40
41
42 43
44 45
46
47
48
49
50
51
52
54 53
55
56
57
58
59
60 61
62
63
65 64
66 67
68
69
70
71
72 73
74
75
76
77
78
79 80
81
83 82
84
85
86
87
88
89
90
91
93 92
94
97 95
98
100 99
101
102
103
104
105
106
108 107
109
110 111
112
113
114
115
116
117
118 119
120
122 121
123
124
125
126
127
128
129
130
131
132
133
135 134
137 136
139 138
140
141
142
143
144
145
146
147
148 149
150
151 152
153
154
156 155 157
158
159
160
161 162
163
165 164
96 at 10
1 2
3 4
5
6
7
8
9 10
11
12
13
14
15
16
17
18
19 20
21
22
24 23
25
26
27
28
29
30
31
32
33
34
35
36
37
39 38
40
41
42
43
44 45
46
47
48
49
50
51
52
53
54
55
56
57
58 59
60
61
62
63
64
65
66
67
68
69
71 70
72
73
74
75
76
77
78 79
80
81
82
83
84
85
86
87
89 88
91
92
93
94
95
96
97
98 99
100
101
102 103
105 104
106
107
108
109
111 110
112
113
114
115
117 116
118 119
120
121
122
123
124
125 126
128
129
130
131
132
133
134
135
136
138 137
140 139
141
142
143
144
145
146
148 147
149
150
152 153
155
156
159 158
161 162
164
165
166
167
168
169
172 170 171
173
175 174
176
178 177
179
180
181
182
183
184 185
186 187
188 189
190
191
192
193 194
195
197 196
198
199
200
201
202
203
204 205
206
207
208
209
210
211
212
213 214
90 at 15 127 at 37 151 at 141 154 at 148 157 at 141 160 at 148
163 at 141
Game 1
Fan Hui (Black), AlphaGo (White)
AlphaGo wins by 2.5 points
Game 2
AlphaGo (Black), Fan Hui (White)
AlphaGo wins by resignation
Game 3
Fan Hui (Black), AlphaGo (White)
AlphaGo wins by resignation
Game 4
AlphaGo (Black), Fan Hui (White)
AlphaGo wins by resignation
Game 5
Fan Hui (Black), AlphaGo (White)
AlphaGo wins by resignation
© 2016 Macmillan Publishers Limited. All rights reserved
28 JANUARY 2016 | VOL 529 | NATURE | 489
ARTICLE RESEARCH
of supervised and reinforcement learning. We have introduced a new
search algorithm that successfully combines neural network evaluations with Monte Carlo rollouts. Our program AlphaGo integrates
these components together, at scale, in a high-performance tree search
engine.
During the match against Fan Hui, AlphaGo evaluated thousands
of times fewer positions than Deep Blue did in its chess match against
Kasparov4
; compensating by selecting those positions more intelligently, using the policy network, and evaluating them more precisely,
using the value network—an approach that is perhaps closer to how
humans play. Furthermore, while Deep Blue relied on a handcrafted
evaluation function, the neural networks of AlphaGo are trained
directly from gameplay purely through general-purpose supervised
and reinforcement learning methods.
Go is exemplary in many ways of the difficulties faced by artificial
intelligence33,34: a challenging decision-making task, an intractable
search space, and an optimal solution so complex it appears infeasible
to directly approximate using a policy or value function. The previous
major breakthrough in computer Go, the introduction of MCTS, led to
corresponding advances in many other domains; for example, general
game-playing, classical planning, partially observed planning, scheduling, and constraint satisfaction35,36. By combining tree search with
policy and value networks, AlphaGo has finally reached a professional
level in Go, providing hope that human-level performance can now be
achieved in other seemingly intractable artificial intelligence domains.
Online Content Methods, along with any additional Extended Data display items and
Source Data, are available in the online version of the paper; references unique to
these sections appear only in the online paper.
Received 11 November 2015; accepted 5 January 2016.
1. Allis, L. V. Searching for Solutions in Games and Artificial Intelligence. PhD thesis,
Univ. Limburg, Maastricht, The Netherlands (1994).
2. van den Herik, H., Uiterwijk, J. W. & van Rijswijck, J. Games solved: now and in
the future. Artif. Intell. 134, 277–311 (2002).
3. Schaeffer, J. The games computers (and people) play. Advances in Computers
52, 189–266 (2000).
4. Campbell, M., Hoane, A. & Hsu, F. Deep Blue. Artif. Intell. 134, 57–83 (2002).
5. Schaeffer, J. et al. A world championship caliber checkers program. Artif. Intell.
53, 273–289 (1992).
6. Buro, M. From simple features to sophisticated evaluation functions.
In 1st International Conference on Computers and Games, 126–145 (1999).
7. Muller, M. Computer Go. Artif. Intell. 134, 145–179 (2002).
8. Tesauro, G. & Galperin, G. On-line policy improvement using Monte-Carlo
search. In Advances in Neural Information Processing, 1068–1074 (1996).
9. Sheppard, B. World-championship-caliber Scrabble. Artif. Intell. 134, 241–275
(2002).
10. Bouzy, B. & Helmstetter, B. Monte-Carlo Go developments. In 10th International
Conference on Advances in Computer Games, 159–174 (2003).
11. Coulom, R. Efficient selectivity and backup operators in Monte-Carlo tree
search. In 5th International Conference on Computers and Games, 72–83
(2006).
12. Kocsis, L. & Szepesvari, C. Bandit based Monte-Carlo planning.
In 15th European Conference on Machine Learning, 282–293 (2006).
13. Coulom, R. Computing Elo ratings of move patterns in the game of Go. ICGA J.
30, 198–208 (2007).
14. Baudis, P. & Gailly, J.-L. Pachi: State of the art open source Go program.
In Advances in Computer Games, 24–38 (Springer, 2012).
15. Muller, M., Enzenberger, M., Arneson, B. & Segal, R. Fuego – an open-source
framework for board games and Go engine based on Monte-Carlo tree search.
IEEE Trans. Comput. Intell. AI in Games 2, 259–270 (2010).
16. Gelly, S. & Silver, D. Combining online and offline learning in UCT.
In 17th International Conference on Machine Learning, 273–280 (2007).
17. Krizhevsky, A., Sutskever, I. & Hinton, G. ImageNet classification with deep
convolutional neural networks. In Advances in Neural Information Processing
Systems, 1097–1105 (2012).
18. Lawrence, S., Giles, C. L., Tsoi, A. C. & Back, A. D. Face recognition:
a convolutional neural-network approach. IEEE Trans. Neural Netw. 8,
98–113 (1997).
19. Mnih, V. et al. Human-level control through deep reinforcement learning.
Nature 518, 529–533 (2015).
20. LeCun, Y., Bengio, Y. & Hinton, G. Deep learning. Nature 521, 436–444 (2015).
21. Stern, D., Herbrich, R. & Graepel, T. Bayesian pattern ranking for move
prediction in the game of Go. In International Conference of Machine Learning,
873–880 (2006).
22. Sutskever, I. & Nair, V. Mimicking Go experts with convolutional neural
networks. In International Conference on Artificial Neural Networks, 101–110
(2008).
23. Maddison, C. J., Huang, A., Sutskever, I. & Silver, D. Move evaluation in Go using
deep convolutional neural networks. 3rd International Conference on Learning
Representations (2015).
24. Clark, C. & Storkey, A. J. Training deep convolutional neural networks to
play go. In 32nd International Conference on Machine Learning, 1766–1774
(2015).
25. Williams, R. J. Simple statistical gradient-following algorithms for connectionist
reinforcement learning. Mach. Learn. 8, 229–256 (1992).
26. Sutton, R., McAllester, D., Singh, S. & Mansour, Y. Policy gradient methods for
reinforcement learning with function approximation. In Advances in Neural
Information Processing Systems, 1057–1063 (2000).
27. Sutton, R. & Barto, A. Reinforcement Learning: an Introduction (MIT Press, 1998).
28. Schraudolph, N. N., Dayan, P. & Sejnowski, T. J. Temporal difference learning
of position evaluation in the game of Go. Adv. Neural Inf. Process. Syst. 6,
817–824 (1994).
29. Enzenberger, M. Evaluation in Go by a neural network using soft segmentation.
In 10th Advances in Computer Games Conference, 97–108 (2003). 267.
30. Silver, D., Sutton, R. & Muller, M. Temporal-difference search in computer Go.
Mach. Learn. 87, 183–219 (2012).
31. Levinovitz, A. The mystery of Go, the ancient game that computers still can’t
win. Wired Magazine (2014).
32. Mechner, D. All Systems Go. The Sciences 38, 32–37 (1998).
33. Mandziuk, J. Computational intelligence in mind games. In Challenges for
Computational Intelligence, 407–442 (2007).
34. Berliner, H. A chronology of computer chess and its literature. Artif. Intell. 10,
201–214 (1978).
35. Browne, C. et al. A survey of Monte-Carlo tree search methods. IEEE Trans.
Comput. Intell. AI in Games 4, 1–43 (2012).
36. Gelly, S. et al. The grand challenge of computer Go: Monte Carlo tree search
and extensions. Commun. ACM 55, 106–113 (2012).
37. Coulom, R. Whole-history rating: A Bayesian rating system for players of
time-varying strength. In International Conference on Computers and Games,
113–124 (2008).
38. KGS. Rating system math. http://www.gokgs.com/help/rmath.html.
Supplementary Information is available in the online version of the paper.
Acknowledgements We thank Fan Hui for agreeing to play against AlphaGo;
T. Manning for refereeing the match; R. Munos and T. Schaul for helpful
discussions and advice; A. Cain and M. Cant for work on the visuals; P. Dayan,
G. Wayne, D. Kumaran, D. Purves, H. van Hasselt, A. Barreto and G. Ostrovski for
reviewing the paper; and the rest of the DeepMind team for their support, ideas
and encouragement.
Author Contributions A.H., G.v.d.D., J.S., I.A., M.La., A.G., T.G. and D.S. designed
and implemented the search in AlphaGo. C.J.M., A.G., L.S., A.H., I.A., V.P., S.D.,
D.G., N.K., I.S., K.K. and D.S. designed and trained the neural networks in
AlphaGo. J.S., J.N., A.H. and D.S. designed and implemented the evaluation
framework for AlphaGo. D.S., M.Le., T.L., T.G., K.K. and D.H. managed and advised
on the project. D.S., T.G., A.G. and D.H. wrote the paper.
Author Information Reprints and permissions information is available at
www.nature.com/reprints. The authors declare no competing financial
interests. Readers are welcome to comment on the online version of the
paper. Correspondence and requests for materials should be addressed to
D.S. (davidsilver@google.com) or D.H. (demishassabis@google.com).
© 2016 Macmillan Publishers Limited. All rights reserved
RESEARCH ARTICLE
METHODS
Problem setting. Many games of perfect information, such as chess, checkers,
othello, backgammon and Go, may be defined as alternating Markov games39. In
these games, there is a state space S (where state includes an indication of the
current player to play); an action space A( )s defining the legal actions in any given
state s?S; a state transition function f(s, a, ?) defining the successor state after
selecting action a in state s and random input ? (for example, dice); and finally a
reward function ri
(s) describing the reward received by player i in state s. We
restrict our attention to two-player zero-sum games, r1
(s)=?r
2
(s)=r(s), with
deterministic state transitions, f(s, a, ?)=f(s, a), and zero rewards except at a terminal time step T. The outcome of the game zt=±r(sT) is the terminal reward at
the end of the game from the perspective of the current player at time step t.
A policy p(a|s) is a probability distribution over legal actions a ? A( )s .
A value function is the expected outcome if all actions for both players are selected
according to policy p, that is, v s( ) = | E[ , z s = ~ s a ... p] p t t t T . Zero-sum games have
a unique optimal value function v*(s) that determines the outcome from state s
following perfect play by both players,
?
( ) = ?
?
?
?
?
?
?
?
=
? ( ( )) v s z s s
v f s a
if ,
max , otherwise
T T
a
Prior work. The optimal value function can be computed recursively by minimax
(or equivalently negamax) search40. Most games are too large for exhaustive minimax tree search; instead, the game is truncated by using an approximate value
function v(s)?v*
(s) in place of terminal rewards. Depth-first minimax search with
alpha–beta pruning40 has achieved superhuman performance in chess4
, checkers5
and othello6
, but it has not been effective in Go7
.
Reinforcement learning can learn to approximate the optimal value function
directly from games of self-play39. The majority of prior work has focused on a
linear combination v?(s)=?(s)· ? of features ?(s) with weights ?. Weights were
trained using temporal-difference learning41 in chess42,43, checkers44,45 and Go30;
or using linear regression in othello6
 and Scrabble9
. Temporal-difference learning
has also been used to train a neural network to approximate the optimal value
function, achieving superhuman performance in backgammon46; and achieving weak kyu-level performance in small-board Go28,29,47 using convolutional
networks.
An alternative approach to minimax search is Monte Carlo tree search
(MCTS)11,12, which estimates the optimal value of interior nodes by a double
approximation, ? V ( )s v ? (s v ) ? ( )s n Pn
. The first approximation, V ( )s v ? (s) n Pn
,
uses n Monte Carlo simulations to estimate the value function of a simulation
policy Pn
. The second approximation, ? v s( ) ? ( v s) Pn
, uses a simulation policy Pn
in place of minimax optimal actions. The simulation policy selects actions according to a search control function argmax ( ( Q s, , a u ) + ( ) s a ) a n , such as UCT12, that
selects children with higher action values, Qn(s, a)=?Vn(f(s, a)), plus a bonus
u(s, a) that encourages exploration; or in the absence of a search tree at state s, it
samples actions from a fast rollout policy ( | ) ?p a s . As more simulations are executed
and the search tree grows deeper, the simulation policy becomes informed by
increasingly accurate statistics. In the limit, both approximations become exact
and MCTS (for example, with UCT) converges12 to the optimal value function ? limn>?V s( ) = ( lim >?v s) = v s( ) n n Pn
. The strongest current Go programs are
based on MCTS13–15,36.
MCTS has previously been combined with a policy that is used to narrow the
beam of the search tree to high-probability moves13; or to bias the bonus term
towards high-probability moves48. MCTS has also been combined with a value
function that is used to initialize action values in newly expanded nodes16, or to
mix Monte Carlo evaluation with minimax evaluation49. By contrast, AlphaGo’s use
of value functions is based on truncated Monte Carlo search algorithms8,9
, which
terminate rollouts before the end of the game and use a value function in place of
the terminal reward. AlphaGo’s position evaluation mixes full rollouts with truncated rollouts, resembling in some respects the well-known temporal-difference
learning algorithm TD(?). AlphaGo also differs from prior work by using slower
but more powerful representations of the policy and value function; evaluating
deep neural networks is several orders of magnitude slower than linear representations and must therefore occur asynchronously.
The performance of MCTS is to a large degree determined by the quality of the
rollout policy. Prior work has focused on handcrafted patterns50 or learning rollout
policies by supervised learning13, reinforcement learning16, simulation balancing51,52 or online adaptation30,53; however, it is known that rollout-based position
evaluation is frequently inaccurate54. AlphaGo uses relatively simple rollouts, and
instead addresses the challenging problem of position evaluation more directly
using value networks.
Search algorithm. To efficiently integrate large neural networks into AlphaGo, we
implemented an asynchronous policy and value MCTS algorithm (APV-MCTS).
Each node s in the search tree contains edges (s, a) for all legal actions a?A( )s .
Each edge stores a set of statistics,
{ , P s( )a N , , v r ( ) s a , , N s( )a W, , v r ( ) s a , , W s( )a Q , , ( ) s a }
where P(s, a) is the prior probability, Wv(s, a) and Wr(s, a) are Monte Carlo estimates of total action value, accumulated over Nv(s, a) and Nr(s, a) leaf evaluations
and rollout rewards, respectively, and Q(s, a) is the combined mean action value for
that edge. Multiple simulations are executed in parallel on separate search threads.
The APV-MCTS algorithm proceeds in the four stages outlined in Fig. 3.
Selection (Fig. 3a). The first in-tree phase of each simulation begins at the root of
the search tree and finishes when the simulation reaches a leaf node at time step
L. At each of these time steps, t<L, an action is selected according to the statistics
in the search tree, a Q t = ( argmax ( ) s a, , + ( u s a)) a t t using a variant of the PUCT
algorithm48, ( ) = ( ) ? ( )
+ ( ) u s a, , c P s a N s b
N s a puct
,
1 ,
b r
r
, where cpuct is a constant determining
the level of exploration; this search control strategy initially prefers actions with
high prior probability and low visit count, but asymptotically prefers actions with
high action value.
Evaluation (Fig. 3c). The leaf position sL is added to a queue for evaluation v?(sL)
by the value network, unless it has previously been evaluated. The second rollout
phase of each simulation begins at leaf node sL and continues until the end of the
game. At each of these time-steps, t?L, actions are selected by both players according to the rollout policy, ~ (?| ) ? a p t ts . When the game reaches a terminal state, the
outcome z r t T = ± ( ) s is computed from the final score.
Backup (Fig. 3d). At each in-tree step t?L of the simulation, the rollout statistics
are updated as if it has lost nvl games, Nr(st, at)<Nr(st, at)+nvl; Wr(st, at)<Wr(st,
at) ?nvl; this virtual loss55 discourages other threads from simultaneously exploring the identical variation. At the end of the simulation, t he rollout statistics are
updated in a backward pass through each step t?L, replacing the virtual losses by
the outcome, Nr(st, at)<Nr(st, at) ?nvl+1; Wr(st, at)<Wr(st, at)+nvl+zt.
Asynchronously, a separate backward pass is initiated when the evaluation
of the leaf position sL completes. The output of the value network v?(sL) is used to
update value statistics in a second backward pass through each step t ? L,
Nv(st, at)<Nv(st, at)+1, Wv(st, at)<Wv(st, at)+v?(sL). The overall evaluation of
each state action is a weighted average of the Monte Carlo estimates,
( ) = ( ? ) ? ? + ( )
( )
( )
( ) Q s a, 1 W s a
N s a
W s a
N s a
,
,
,
,
v
v
r
r
, that mixes together the value network and
rollout evaluations with weighting parameter ?. All updates are performed
lock-free56.
Expansion (Fig. 3b). When the visit count exceeds a threshold, Nr(s, a)>nthr , the
successor state s?=f(s, a) is added to the search tree. The new node is initialized
to {N(s?, a)=Nr(s?, a)=0, W(s?, a)=Wr(s?, a)=0, P(s?,a)=p?(a|s?)}, using a tree
policy p?(a|s?) (similar to the rollout policy but with more features, see Extended
Data Table 4) to provide placeholder prior probabilities for action selection. The
position s? is also inserted into a queue for asynchronous GPU evaluation by the
policy network. Prior probabilities are computed by the SL policy network (?| ?) ?
?p s
with a softmax temperature set to ?; these replace the placeholder prior probabilities, ( ? ) < ( | ?) ?
? P s a, p a s , using an atomic update. The threshold nthr is adjusted
dynamically to ensure that the rate at which positions are added to the policy queue
matches the rate at which the GPUs evaluate the policy network. Positions are
evaluated by both the policy network and the value network using a mini-batch
size of 1 to minimize end-to-end evaluation time.
We also implemented a distributed APV-MCTS algorithm. This architecture
consists of a single master machine that executes the main search, many remote
worker CPUs that execute asynchronous rollouts, and many remote worker GPUs
that execute asynchronous policy and value network evaluations. The entire search
tree is stored on the master, which only executes the in-tree phase of each simulation. The leaf positions are communicated to the worker CPUs, which execute
the rollout phase of simulation, and to the worker GPUs, which compute network
features and evaluate the policy and value networks. The prior probabilities of the
policy network are returned to the master, where they replace placeholder prior
probabilities at the newly expanded node. The rewards from rollouts and the value
network outputs are each returned to the master, and backed up the originating
search path.
At the end of search AlphaGo selects the action with maximum visit count; this
is less sensitive to outliers than maximizing action value15. The search tree is reused
at subsequent time steps: the child node corresponding to the played action
becomes the new root node; the subtree below this child is retained along with all
its statistics, while the remainder of the tree is discarded. The match version of
AlphaGo continues searching during the opponent’s move. It extends the search
© 2016 Macmillan Publishers Limited. All rights reserved
ARTICLE RESEARCH
if the action maximizing visit count and the action maximizing action value disagree. Time controls were otherwise shaped to use most time in the middle-game57.
AlphaGo resigns when its overall evaluation drops below an estimated 10% probability of winning the game, that is, maxa Q s( ) , 0 a < ? .8.
AlphaGo does not employ the all-moves-as-first10 or rapid action value estimation58 heuristics used in the majority of Monte Carlo Go programs; when using
policy networks as prior knowledge, these biased heuristics do not appear to give
any additional benefit. In addition AlphaGo does not use progressive widening13,
dynamic komi59 or an opening book60. The parameters used by AlphaGo in the
Fan Hui match are listed in Extended Data Table 5.
Rollout policy. The rollout policy ( | ) ?p a s is a linear softmax policy based on fast,
incrementally computed, local pattern-based features consisting of both ‘response’
patterns around the previous move that led to state s, and ‘non-response’ patterns
around the candidate move a in state s. Each non-response pattern is a binary
feature matching a specific 3?3 pattern centred on a, defined by the colour (black,
white, empty) and liberty count (1, 2, ?3) for each adjacent intersection. Each
response pattern is a binary feature matching the colour and liberty count in a
12-point diamond-shaped pattern21 centred around the previous move.
Additionally, a small number of handcrafted local features encode common-sense
Go rules (see Extended Data Table 4). Similar to the policy network, the weights
? of the rollout policy are trained from 8 million positions from human games on
the Tygem server to maximize log likelihood by stochastic gradient descent.
Rollouts execute at approximately 1,000 simulations per second per CPU thread
on an empty board.
Our rollout policy p?(a|s) contains less handcrafted knowledge than stateof-the-art Go programs13. Instead, we exploit the higher-quality action selection
within MCTS, which is informed both by the search tree and the policy network.
We introduce a new technique that caches all moves from the search tree and
then plays similar moves during rollouts; a generalization of the ‘last good reply’
heuristic53. At every step of the tree traversal, the most probable action is inserted
into a hash table, along with the 3?3 pattern context (colour, liberty and stone
counts) around both the previous move and the current move. At each step of the
rollout, the pattern context is matched against the hash table; if a match is found
then the stored move is played with high probability.
Symmetries. In previous work, the symmetries of Go have been exploited by using
rotationally and reflectionally invariant filters in the convolutional layers24,28,29.
Although this may be effective in small neural networks, it actually hurts performance in larger networks, as it prevents the intermediate filters from identifying
specific asymmetric patterns23. Instead, we exploit symmetries at run-time by
dynamically transforming each position s using the dihedral group of eight reflections and rotations, d1(s), …, d8(s). In an explicit symmetry ensemble, a mini-batch
of all 8 positions is passed into the policy network or value network and computed
in parallel. For the value network, the output values are simply averaged,
v s ? ? ( ) = ? = v d( (s)) j j 1
8 1
8 . For the policy network, the planes of output probabilities
are rotated/reflected back into the original orientation, and averaged together to
provide an ensemble prediction, (?| ) = ? ( (?| ( ))) ? ? = ? p s d p d s j j j 1
8 1 8 1 ; this approach
was used in our raw network evaluation (see Extended Data Table 3). Instead,
APV-MCTS makes use of an implicit symmetry ensemble that randomly selects a
single rotation/reflection j ? [1, 8] for each evaluation. We compute exactly one
evaluation for that orientation only; in each simulation we compute the value
of leaf node sL by v?(dj(sL)), and allow the search procedure to average over
these evaluations. Similarly, we compute the policy network for a single,
randomly selected rotation/reflection, ( (?| ( ))) ?
?d p d s j j 1 .
Policy network: classification. We trained the policy network p? to classify positions according to expert moves played in the KGS data set. This data set contains
29.4 million positions from 160,000 games played by KGS 6 to 9 dan human players; 35.4% of the games are handicap games. The data set was split into a test set
(the first million positions) and a training set (the remaining 28.4 million positions). Pass moves were excluded from the data set. Each position consisted of a
raw board description s and the move a selected by the human. We augmented the
data set to include all eight reflections and rotations of each position. Symmetry
augmentation and input features were pre-computed for each position. For each
training step, we sampled a randomly selected mini-batch of m samples from
the augmented KGS data set, = {s a, } k k
k
m
1
 and applied an asynchronous stochastic
gradient descent update to maximize the log likelihood of the action,
?? = ??
? =
? ( | )
?
?
m k
m p a s
1
log k k
. The step size ? was initialized to 0.003 and was halved
every 80 million training steps, without momentum terms, and a mini-batch size
of m=16. Updates were applied asynchronously on 50 GPUs using DistBelief 61;
gradients older than 100 steps were discarded. Training took around 3 weeks for
340 million training steps.
Policy network: reinforcement learning. We further trained the policy network
by policy gradient reinforcement learning25,26. Each iteration consisted of a minibatch of n games played in parallel, between the current policy network p? that is
being trained, and an opponent ? p ? that uses parameters ?? from a previous iteration, randomly sampled from a pool of opponents, so as to increase the stability
of training. Weights were initialized to ?=?? =?. Every 500 iterations, we added
the current parameters ? to the opponent pool. Each game i in the mini-batch was
played out until termination at step Ti
, and then scored to determine the outcome
z r = ± ( ) s t
i
Ti from each player’s perspective. The games were then replayed to
determine the policy gradient update, ?? = ? ? ( ? ( )) ?
? = =
? ( | )
?
? z v s n i
n
t
T p a s
t
i
t
i 1 1
i log t
i t
i
 ,
using the REINFORCE algorithm25 with baseline v s( )t
i for variance reduction. On
the first pass through the training pipeline, the baseline was set to zero; on the
second pass we used the value network v?(s) as a baseline; this provided a small
performance boost. The policy network was trained in this way for 10,000 minibatches of 128 games, using 50 GPUs, for one day.
Value network: regression. We trained a value network v s ?( ) ? ( v s ? ) p to approximate the value function of the RL policy network p?. To avoid overfitting to the
strongly correlated positions within games, we constructed a new data set of uncorrelated self-play positions. This data set consisted of over 30 million positions, each
drawn from a unique game of self-play. Each game was generated in three phases
by randomly sampling a time step U~unif{1, 450}, and sampling the first t=1,…
U?1 moves from the SL policy network, at~p?(·|st); then sampling one move
uniformly at random from available moves, aU~unif{1, 361} (repeatedly until
aU is legal); then sampling the remaining sequence of moves until the game terminates, t=U+1, … T, from the RL policy network, at~p?(·|st). Finally, the game
is scored to determine the outcome zt=±r(sT). Only a single training example
(sU+1, zU+1) is added to the data set from each game. This data provides unbiased
samples of the value function ( ) + + = | E + + ... ~ ? v s ? [ , z s a p ] p U U 1 1 U U 1 1, T . During
the first two phases of generation we sample from noisier distributions so as
to increase the diversity of the data set. The training method was identical
to SL policy network training, except that the parameter update was based on
mean squared error between the predicted values and the observed rewards,
?? = ? ( ? ( )) ? ? ? =
? ( )
?
? z v s m k
m k k v s
1
k
 . The value network was trained for 50 million
mini-batches of 32 positions, using 50 GPUs, for one week.
Features for policy/value network. Each position s was pre-processed into a set
of 19?19 feature planes. The features that we use come directly from the raw
representation of the game rules, indicating the status of each intersection of the
Go board: stone colour, liberties (adjacent empty points of stone’s chain), captures,
legality, turns since stone was played, and (for the value network only) the current
colour to play. In addition, we use one simple tactical feature that computes the
outcome of a ladder search7
. All features were computed relative to the current
colour to play; for example, the stone colour at each intersection was represented
as either player or opponent rather than black or white. Each integer feature value
is split into multiple 19?19 planes of binary values (one-hot encoding). For example, separate binary feature planes are used to represent whether an intersection
has 1 liberty, 2 liberties,…, ?8 liberties. The full set of feature planes are listed in
Extended Data Table 2.
Neural network architecture. The input to the policy network is a 19?19?48
image stack consisting of 48 feature planes. The first hidden layer zero pads the
input into a 23?23 image, then convolves k filters of kernel size 5?5 with stride
1 with the input image and applies a rectifier nonlinearity. Each of the subsequent
hidden layers 2 to 12 zero pads the respective previous hidden layer into a 21?21
image, then convolves k filters of kernel size 3?3 with stride 1, again followed
by a rectifier nonlinearity. The final layer convolves 1 filter of kernel size 1?1
with stride 1, with a different bias for each position, and applies a softmax function. The match version of AlphaGo used k=192 filters; Fig. 2b and Extended
Data Table 3 additionally show the results of training with k =128, 256 and
384 filters.
The input to the value network is also a 19?19?48 image stack, with an additional binary feature plane describing the current colour to play. Hidden layers 2 to
11 are identical to the policy network, hidden layer 12 is an additional convolution
layer, hidden layer 13 convolves 1 filter of kernel size 1?1 with stride 1, and hidden
layer 14 is a fully connected linear layer with 256 rectifier units. The output layer
is a fully connected linear layer with a single tanh unit.
Evaluation. We evaluated the relative strength of computer Go programs by running an internal tournament and measuring the Elo rating of each program. We
estimate the probability that program a will beat program b by a logistic function
( ) = + ( ( ( ) ? ( )) p a beats b c e b e a
1
1 exp elo
, and estimate the ratings e(·) by Bayesian
logistic regression, computed by the BayesElo program37 using the standard
constant celo=1/400. The scale was anchored to the BayesElo rating of professional
© 2016 Macmillan Publishers Limited. All rights reserved
RESEARCH ARTICLE
Go player Fan Hui (2,908 at date of submission)62. All programs received a maximum of 5s computation time per move; games were scored using Chinese rules
with a komi of 7.5 points (extra points to compensate white for playing second).
We also played handicap games where AlphaGo played white against existing Go
programs; for these games we used a non-standard handicap system in which komi
was retained but black was given additional stones on the usual handicap points.
Using these rules, a handicap of K stones is equivalent to giving K?1 free moves
to black, rather than K?1/2 free moves using standard no-komi handicap rules.
We used these handicap rules because AlphaGo’s value network was trained specifically to use a komi of 7.5.
With the exception of distributed AlphaGo, each computer Go program was
executed on its own single machine, with identical specifications, using the latest
available version and the best hardware configuration supported by that program
(see Extended Data Table 6). In Fig. 4, approximate ranks of computer programs
are based on the highest KGS rank achieved by that program; however, the KGS
version may differ from the publicly available version.
The match against Fan Hui was arbitrated by an impartial referee. Five
formal games and five informal games were played with 7.5 komi, no handicap, and Chinese rules. AlphaGo won these games 5–0 and 3–2 respectively
(Fig. 6 and Extended Data Table 1). Time controls for formal games were 1h main
time plus three periods of 30 s byoyomi. Time controls for informal games were
three periods of 30 s byoyomi. Time controls and playing conditions were chosen
by Fan Hui in advance of the match; it was also agreed that the overall match
outcome would be determined solely by the formal games. To approximately
assess the relative rating of Fan Hui to computer Go programs, we appended the
results of all ten games to our internal tournament results, ignoring differences
in time controls.
39. Littman, M. L. Markov games as a framework for multi-agent reinforcement
learning. In 11th International Conference on Machine Learning, 157–163
(1994).
40. Knuth, D. E. & Moore, R. W. An analysis of alpha-beta pruning. Artif. Intell. 6,
293–326 (1975).
41. Sutton, R. Learning to predict by the method of temporal differences.
Mach. Learn. 3, 9–44 (1988).
42. Baxter, J., Tridgell, A. & Weaver, L. Learning to play chess using temporal
differences. Mach. Learn. 40, 243–263 (2000).
43. Veness, J., Silver, D., Blair, A. & Uther, W. Bootstrapping from game tree search.
In Advances in Neural Information Processing Systems (2009).
44. Samuel, A. L. Some studies in machine learning using the game of checkers
II - recent progress. IBM J. Res. Develop. 11, 601–617 (1967).
45. Schaeffer, J., Hlynka, M. & Jussila, V. Temporal difference learning applied to a
high-performance game-playing program. In 17th International Joint
Conference on Artificial Intelligence, 529–534 (2001).
46. Tesauro, G. TD-gammon, a self-teaching backgammon program, achieves
master-level play. Neural Comput. 6, 215–219 (1994).
47. Dahl, F. Honte, a Go-playing program using neural nets. In Machines that learn
to play games, 205–223 (Nova Science, 1999).
48. Rosin, C. D. Multi-armed bandits with episode context. Ann. Math. Artif. Intell.
61, 203–230 (2011).
49. Lanctot, M., Winands, M. H. M., Pepels, T. & Sturtevant, N. R. Monte Carlo tree
search with heuristic evaluations using implicit minimax backups. In IEEE
Conference on Computational Intelligence and Games, 1–8 (2014).
50. Gelly, S., Wang, Y., Munos, R. & Teytaud, O. Modification of UCT with patterns in
Monte-Carlo Go. Tech. Rep. 6062, INRIA (2006).
51. Silver, D. & Tesauro, G. Monte-Carlo simulation balancing. In 26th International
Conference on Machine Learning, 119 (2009).
52. Huang, S.-C., Coulom, R. & Lin, S.-S. Monte-Carlo simulation balancing in
practice. In 7th International Conference on Computers and Games, 81–92
(Springer-Verlag, 2011).
53. Baier, H. & Drake, P. D. The power of forgetting: improving the last-good-reply
policy in Monte Carlo Go. IEEE Trans. Comput. Intell. AI in Games 2, 303–309
(2010).
54. Huang, S. & Muller, M. Investigating the limits of Monte-Carlo tree search
methods in computer Go. In 8th International Conference on Computers and
Games, 39–48 (2013).
55. Segal, R. B. On the scalability of parallel UCT. Computers and Games 6515,
36–47 (2011).
56. Enzenberger, M. & Muller, M. A lock-free multithreaded Monte-Carlo tree
search algorithm. In 12th Advances in Computer Games Conference, 14–20
(2009).
57. Huang, S.-C., Coulom, R. & Lin, S.-S. Time management for Monte-Carlo tree
search applied to the game of Go. In International Conference on Technologies
and Applications of Artificial Intelligence, 462–466 (2010).
58. Gelly, S. & Silver, D. Monte-Carlo tree search and rapid action value estimation
in computer Go. Artif. Intell. 175, 1856–1875 (2011).
59. Baudis, P. Balancing MCTS by dynamically adjusting the komi value. ICGA J.
34, 131 (2011).
60. Baier, H. & Winands, M. H. Active opening book application for Monte-Carlo
tree search in 19?19 Go. In Benelux Conference on Artificial Intelligence,
3–10 (2011).
61. Dean, J. et al. Large scale distributed deep networks. In Advances in Neural
Information Processing Systems, 1223–1231 (2012).
62. Go ratings. http://www.goratings.org.
© 2016 Macmillan Publishers Limited. All rights reserved
ARTICLE RESEARCH
Extended Data Table 1 | Details of match between AlphaGo and Fan Hui
Date Black White Category Result
5/10/15 Fan Hui AlphaGo Formal AlphaGo wins by 2.5 points
5/10/15 Fan Hui AlphaGo Informal Fan Hui wins by resignation
6/10/15 AlphaGo Fan Hui Formal AlphaGo wins by resignation
6/10/15 AlphaGo Fan Hui Informal AlphaGo wins by resignation
7/10/15 Fan Hui AlphaGo Formal AlphaGo wins by resignation
7/10/15 Fan Hui AlphaGo Informal AlphaGo wins by resignation
8/10/15 AlphaGo Fan Hui Formal AlphaGo wins by resignation
8/10/15 AlphaGo Fan Hui Informal AlphaGo wins by resignation
9/10/15 Fan Hui AlphaGo Formal AlphaGo wins by resignation
9/10/15 AlphaGo Fan Hui Informal Fan Hui wins by resignation
The match consisted of five formal games with longer time controls, and five informal games with shorter time controls.
Time controls and playing conditions were chosen by Fan Hui in advance of the match.
© 2016 Macmillan Publishers Limited. All rights reserved
RESEARCH ARTICLE
Extended Data Table 2 | Input features for neural networks
Feature # of planes Description
Stone colour 3 Player stone / opponent stone / empty
Ones 1 A constant plane filled with 1
Turns since 8 How many turns sinceamove was played
Liberties 8 Number of liberties (empty adjacent points)
Capture size 8 How many opponent stones would be captured
Self-atari size 8 How many of own stones would be captured
Liberties after move 8 Number of liberties after this move is played
Ladder capture 1 Whetheramove at this point is a successful ladder capture
Ladder escape 1 Whetheramove at this point is a successful ladder escape
Sensibleness 1 Whetheramove is legal and does not fill its own eyes
Zeros 1 A constant plane filled with 0
Player color 1 Whether current player is black
Feature planes used by the policy network (all but last feature) and value network (all features).
© 2016 Macmillan Publishers Limited. All rights reserved
ARTICLE RESEARCH
Extended Data Table 3 | Supervised learning results for the policy network
Architecture Evaluation
Filters Symmetries Features Test accuracy %
Train accuracy %
Raw net
wins %
AlphaGo
wins %
Forward
time (ms)
128 1 48 54.6 57.0 36 53 2.8
192 1 48 55.4 58.0 50 50 4.8
256 1 48 55.9 59.1 67 55 7.1
256 2 48 56.5 59.8 67 38 13.9
256 4 48 56.9 60.2 69 14 27.6
256 8 48 57.0 60.4 69 5 55.3
192 1 4 47.6 51.4 25 15 4.8
192 1 12 54.7 57.1 30 34 4.8
192 1 20 54.7 57.2 38 40 4.8
192 8 4 49.2 53.2 24 2 36.8
192 8 12 55.7 58.3 32 3 36.8
192 8 20 55.8 58.4 42 3 36.8
The policy network architecture consists of 128, 192 or 256 filters in convolutional layers; an explicit symmetry ensemble over 2, 4 or 8 symmetries; using only the first 4, 12 or
20 input feature planes listed in Extended Data Table 1. The results consist of the test and train accuracy on the KGS data set; and the percentage of games won by given policy
network against AlphaGo’s policy network (highlighted row 2): using the policy networks to select moves directly (raw wins); or using AlphaGo’s search to select moves (AlphaGo
wins); and finally the computation time for a single evaluation of the policy network.
© 2016 Macmillan Publishers Limited. All rights reserved
RESEARCH ARTICLE
Extended Data Table 4 | Input features for rollout and tree policy
Features used by the rollout policy (first set) and tree policy (first and second set). Patterns are based on stone colour (black/white/empty) and liberties (1, 2, ?3)
at each intersection of the pattern.
© 2016 Macmillan Publishers Limited. All rights reserved
ARTICLE RESEARCH
Extended Data Table 5 | Parameters used by AlphaGo
Symbol Parameter Value
? Softmax temperature 0.67
? Mixing parameter 0.5
nvl Virtual loss 3
nthr Expansion threshold 40
cpuct Exploration constant 5
© 2016 Macmillan Publishers Limited. All rights reserved
RESEARCH ARTICLE
Extended Data Table 6 | Results of a tournament between different Go programs
Short name Computer Player Version Time settings CPUs GPUs KGS Rank Elo
?d
rvp Distributed AlphaGo See Methods 5 seconds 1202 176 – 3140
?rvp AlphaGo See Methods 5 seconds 48 8 – 2890
CS CrazyStone 2015 5 seconds 32 – 6d 1929
ZN Zen 5 5 seconds 8 – 6d 1888
P C Pachi 10.99 400,000 sims 16 – 2d 1298
F G Fuego svn1989 100,000 sims 16 – – 1148
GG GnuGo 3.8 level 10 1 – 5k 431
CS4 CrazyStone 4 handicap stones 5 seconds 32 – – 2526
ZN4 Zen 4 handicap stones 5 seconds 8 – – 2413
P C4 Pachi 4 handicap stones 400,000 sims 16 – – 1756
Each program played with a maximum of 5 s thinking time per move; the games against Fan Hui were conducted using longer time controls, as described in Methods. CN4, ZN4
and PC4 were given 4 handicap stones; komi was 7.5 in all games. Elo ratings were computed by BayesElo.
© 2016 Macmillan Publishers Limited. All rights reserved
ARTICLE RESEARCH
Extended Data Table 7 | Results of a tournament between different variants of AlphaGo
Short Policy Value Rollouts Mixing Policy Value Elo
name network network constant GPUs GPUs rating
?rvp p? v? p? ? = 0.5 2 6 2890
?vp p? v? – ? = 0 2 6 2177
?rp p? – p? ? = 1 8 0 2416
?rv [p? ] v? p? ? = 0.5 0 8 2077
?v [p? ] v? – ? = 0 0 8 1655
?r [p? ] – p? ? = 1 0 0 1457
?p p? –––00 1517
Evaluating positions using rollouts only (?rp, ?r), value nets only (?vp, ?v), or mixing both (?rvp, ?rv); either using the policy network p?(?rvp, ?vp, ?rp), or no policy
network (?rvp, ?vp, ?rp), that is, instead using the placeholder probabilities from the tree policy p? throughout. Each program used 5 s per move on a single machine
with 48 CPUs and 8 GPUs. Elo ratings were computed by BayesElo.
© 2016 Macmillan Publishers Limited. All rights reserved
RESEARCH ARTICLE
Extended Data Table 8 | Results of a tournament between AlphaGo and distributed AlphaGo, testing scalability
with hardware
AlphaGo Search threads CPUs GPUs Elo
Asynchronous 1 48 8 2203
Asynchronous 2 48 8 2393
Asynchronous 4 48 8 2564
Asynchronous 8 48 8 2665
Asynchronous 16 48 8 2778
Asynchronous 32 48 8 2867
Asynchronous 40 48 8 2890
Asynchronous 40 48 1 2181
Asynchronous 40 48 2 2738
Asynchronous 40 48 4 2850
Distributed 12 428 64 2937
Distributed 24 764 112 3079
Distributed 40 1202 176 3140
Distributed 64 1920 280 3168
Each program played with a maximum of 2s thinking time per move. Elo ratings were computed by BayesElo.
© 2016 Macmillan Publishers Limited. All rights reserved
ARTICLE RESEARCH
Extended Data Table 9 | Cross-table of win rates in per cent between programs
?rvp ?vp ?rp ?rv ?r ?v ?p
?rvp - 1 [0; 5] 5 [4; 7] 0 [0; 4] 0 [0; 8] 0 [0; 19] 0 [0; 19]
?vp 99 [95; 100] - 61 [52; 69] 35 [25; 48] 6 [1; 27] 0 [0; 22] 1 [0; 6]
?rp 95 [93; 96] 39 [31; 48] - 13 [7; 23] 0 [0; 9] 0 [0; 22] 4 [1; 21]
?rv 100 [96; 100] 65 [52; 75] 87 [77; 93] - 0 [0; 18] 29 [8; 64] 48 [33; 65]
?r 100 [92; 100] 94 [73; 99] 100 [91; 100] 100 [82; 100] - 78 [45; 94] 78 [71; 84]
?v 100 [81; 100] 100 [78; 100] 100 [78; 100] 71 [36; 92] 22 [6; 55] - 30 [16; 48]
?p 100 [81; 100] 99 [94; 100] 96 [79; 99] 52 [35; 67] 22 [16; 29] 70 [52; 84] -
CS 100 [97; 100] 74 [66; 81] 98 [94; 99] 80 [70; 87] 5 [3; 7] 36 [16; 61] 8 [5; 14]
ZN 99 [93; 100] 84 [67; 93] 98 [93; 99] 92 [67; 99] 6 [2; 19] 40 [12; 77] 100 [65; 100]
P C 100 [98; 100] 99 [95; 100] 100 [98; 100] 98 [89; 100] 78 [73; 81] 87 [68; 95] 55 [47; 62]
F G 100 [97; 100] 99 [93; 100] 100 [96; 100] 100 [91; 100] 78 [73; 83] 100 [65; 100] 65 [55; 73]
GG 100 [44; 100] 100 [34; 100] 100 [68; 100] 100 [57; 100] 99 [97; 100] 67 [21; 94] 99 [95; 100]
CS4 77 [69; 84] 12 [8; 18] 53 [44; 61] 15 [8; 24] 0 [0; 3] 0 [0; 30] 0 [0; 8]
ZN4 86 [77; 92] 25 [16; 38] 67 [56; 76] 14 [7; 27] 0 [0; 12] 0 [0; 43] -
P C4 99 [97; 100] 82 [75; 88] 98 [95; 99] 89 [79; 95] 32 [26; 39] 13 [3; 36] 35 [25; 46]
95% Agresti–Coull confidence intervals in grey. Each program played with a maximum of 5s thinking time per move. CN4, ZN4 and PC4 were given 4 handicap stones;
komi was 7.5 in all games. Distributed AlphaGo scored 77% [70; 82] against ?rvp and 100% against all other programs (no handicap games were played).
© 2016 Macmillan Publishers Limited. All rights reserved
RESEARCH ARTICLE
Extended Data Table 10 | Cross-table of win rates in per cent between programs in the single-machine scalability study
Threads 124 8 16 32 40 40 40 40
GPU 8888 8884 2 1
1 8 - 70 [61;78] 90 [84;94] 94 [83;98] 86 [72;94] 98 [91;100] 98 [92;99] 100 [76;100] 96 [91;98] 38 [25;52]
2 8 30 [22;39] - 72 [61;81] 81 [71;88] 86 [76;93] 92 [83;97] 93 [86;96] 83 [69;91] 84 [75;90] 26 [17;38]
4 8 10 [6;16] 28 [19;39] - 62 [53;70] 71 [61;80] 82 [71;89] 84 [74;90] 81 [69;89] 78 [63;88] 18 [10;28]
8 8 6 [2;17] 19 [12;29] 38 [30;47] - 61 [51;71] 65 [51;76] 73 [62;82] 74 [59;85] 64 [55;73] 12 [3;34]
16 8 14 [6;28] 14 [7;24] 29 [20;39] 39 [29;49] - 52 [41;63] 61 [50;71] 52 [41;64] 41 [32;51] 5 [1;25]
32 8 2 [0;9] 8 [3;17] 18 [11;29] 35 [24;49] 48 [37;59] - 52 [42;63] 44 [32;57] 26 [17;36] 0 [0;30]
40 8 2 [1;8] 8 [4;14] 16 [10;26] 27 [18;38] 39 [29;50] 48 [37;58] - 43 [30;56] 41 [26;58] 4 [1;18]
40 4 0 [0;24] 17 [9;31] 19 [11;31] 26 [15;41] 48 [36;59] 56 [43;68] 57 [44;70] - 29 [18;41] 2 [0;11]
40 2 4 [2;9] 16 [10;25] 22 [12;37] 36 [27;45] 59 [49;68] 74 [64;83] 59 [42;74] 71 [59;82] - 5 [1;17]
40 1 62 [48;75] 74 [62;83] 82 [72;90] 88 [66;97] 95 [75;99] 100 [70;100] 96 [82;99] 98 [89;100] 95 [83;99] -
95% Agresti–Coull confidence intervals in grey. Each program played with 2s per move; komi was 7.5 in all games.
© 2016 Macmillan Publishers Limited. All rights reserved
ARTICLE RESEARCH
Extended Data Table 11 | Cross-table of win rates in per cent between programs
in the distributed scalability study
Threads 40 12 24 40 64
GPU 8 64 112 176 280
CPU 48 428 764 1202 1920
40 8 48 - 52 [43; 61] 68 [59; 76] 77 [70; 82] 81 [65; 91]
12 64 428 48 [39; 57] - 64 [54; 73] 62 [41; 79] 83 [55; 95]
24 112 764 32 [24; 41] 36 [27; 46] - 36 [20; 57] 60 [51; 69]
40 176 1202 23 [18; 30] 38 [21; 59] 64 [43; 80] - 53 [39; 67]
64 280 1920 19 [9; 35] 17 [5; 45] 40 [31; 49] 47 [33; 61] -
95% Agresti–Coull confidence intervals in grey. Each program played with 2s per move; komi was 7.5 in all games.
© 2016 Macmillan Publishers Limited. All rights reserved